<html>
  <head>
    <meta charset="utf-8">
    <title>CVdrawing</title>
  </head>
  <body>
    <p id="status">OpenCV.js is loading...</p>
    <canvas id="canvas" disabled=true></canvas>
    <img id="src" src="fruits.jpg"/>
    <input type="button" id="myButton" value="Test" onclick="" />
    <input type="button" id="startAlgo" value="Start" disabled=true onclick="main()">

    <script type="text/javascript">

      var src;
      var zero_crossing;
      var img_canny;
      var grayscale;
      var Ix;
      var Iy;
      var gradient_magnitude;
      var cost;
      var hit_map_x;
      var hit_map_y;
      let lastX;
      let lastY;

      class PriorityQueue 
      {
        constructor() 
        {
            this.queue = [];
        }

        enqueue(obj, level)
        {
          let i = 0;
          while(i < this.queue.length && this.queue[i].level < level)
            ++i;
          this.queue.splice(i,0,{
            value : obj,
            level
          });
        }

        dequeue()
        {
          return this.queue.shift();
        }

        empty()
        {
          return this.queue.length === 0;
        }

        length()
        {
          return this.queue.length;
        }

        top()
        {
          return this.queue[0];
        }
      }

      window.onload = function()
      {
        context = document.getElementById("canvas").getContext("2d");
        img = document.getElementById("src");
        context.canvas.width = img.width;
        context.canvas.height = img.height;
        context.drawImage(img, 0, 0);
      };


      function local_cost(p, q)
      {
        let dp;
        let dq;
        let fG = gradient_magnitude.floatAt(q.x, q.y);
        let WEIGHT_LAP_ZERO_CROSS = 0.43;
        let WEIGHT_GRADIENT_MAGNITUDE = 0.14;
        let WEIGHT_GRADIENT_DIRECTION = 0.43;
        let isDiag = (p.x != q.x) && (p.y != q.y);
        if ((Iy.floatAt(p.x, p.y) * (q.x - p.x) - Ix.floatAt(p.x, p.y) * (q.y - p.y)) >= 0)
        {
          dp = Iy.floatAt(p.x, p.y) * (q.x - p.x) - Ix.floatAt(p.x, p.y) * (q.y - p.y);
          dq = Iy.floatAt(q.x, q.y) * (q.x - p.x) - Ix.floatAt(q.x, q.y) * (q.y - p.y);
        }
        else
        {
          dp = Iy.floatAt(p.x, p.y) * (p.x - q.x) - Ix.floatAt(p.x, p.y) * (p.y - q.y);
          dq = Iy.floatAt(q.x, q.y) * (p.x - q.x) - Ix.floatAt(q.x, q.y) * (p.y - q.y);
        }
        if (isDiag)
        {
          dp /= Math.sqrt(2);
          dq /= Math.sqrt(2);
        }
        else
        {
          fG /= Math.sqrt(2);
        }

        return WEIGHT_LAP_ZERO_CROSS * zero_crossing.floatAt(q.x, q.y) +  WEIGHT_GRADIENT_DIRECTION * (Math.cos(dp) + Math.cos(dq) / Math.PI) + WEIGHT_GRADIENT_MAGNITUDE *fG;
      }

      function find_min_path(start)
      {
        let begin;
        
        let cost_map = new cv.Mat(src.rows, src.cols, cv.CV_32F, new cv.Scalar(Number.MAX_VALUE));
        let expandned = new cv.Mat(src.rows, src.cols, cv.CV_8UC1, new cv.Scalar(0));
        let processed = new cv.Mat(src.rows, src.cols, cv.CV_8U, new cv.Scalar(0));
        let removed = new cv.Mat(src.rows, src.cols, cv.CV_8UC1, new cv.Scalar(0));
        let L = new PriorityQueue();
        hit_map_x = new cv.Mat(src.rows, src.cols, cv.CV_32S, new cv.Scalar(0));
        hit_map_y = new cv.Mat(src.rows, src.cols, cv.CV_32S, new cv.Scalar(0));
        cost_map.floatPtr(start.x, start.y)[0] = 0;
        processed.ucharPtr(start.x, start.y)[0] = 1;

        begin = {cost: 0, next_point: start};
        L.enqueue(begin.next_point, begin.cost);
        
        while(!L.empty())
        {
          let P = L.top();
          console.log(P.value);
          L.dequeue(); 
          console.log(P.level);

          let p = P.value;
          processed.ucharPtr(p.x,p.y)[0] = 0;

          if (removed.ucharAt(start.x, start.y) == 0)
          {
            expandned.ucharPtr(p.x, p.y)[0] = 1;
            for(let i = -1; i <= 1; i++)
            {
              for(let j = -1; j <= 1; j++)
              {
                let tx = p.x + i;
                let ty = p.y + j;
                if (tx < 0 || tx >= src.cols || ty < 0 || ty >= src.rows)
                  continue;
                if (expandned.ucharPtr(tx,ty)[0]==0)
                {
                  let q = {x: tx,y: ty};

                  let cost = cost_map.floatPtr(p.x,p.y)[0]  +  local_cost(p, q);
                  if (processed.ucharPtr(q.x,q.y)[0] == 1 && cost < cost_map.floatPtr(q.x,q.y)[0])
                  {
                    removed.ucharPtr(q.x,q.y)[0] = 1;
                  }
                  if (processed.ucharPtr(q.x,q.y)[0] == 0)
                  {
                    cost_map.floatPtr(q.x,q.y)[0]= cost;
                    hit_map_x.intPtr(q.x, q.y)[0] = p.x;
                    hit_map_y.intPtr(q.x, q.y)[0] = p.y;
                    processed.ucharPtr(q.x,q.y)[0] = 1
                    let val = {cost: cost_map.floatPtr(q.x,q.y), next_point: q}
                    L.enqueue(q,cost_map.floatPtr(q.x,q.y));
                  }
                }    
              }
            }
          }
          cv.imshow("canvas",  src);
        }
      }

      function main()
      {
        src = cv.imread("src");
        zero_crossing = new cv.Mat();
        img_canny = new cv.Mat();
        grayscale = new cv.Mat();
        Ix = new cv.Mat();
        Iy = new cv.Mat();
        
        gradient_magnitude = new cv.Mat();
        cv.cvtColor(src, grayscale, cv.COLOR_BGR2GRAY);
        cv.Canny(grayscale, img_canny,  50, 100);  
        cv.threshold(img_canny, zero_crossing, 254, 1, cv.THRESH_BINARY_INV);
        cv.Sobel(grayscale, Ix, cv.CV_32FC1, 1, 0, 1);
        cv.Sobel(grayscale, Iy, cv.CV_32FC1, 0, 1, 1);
      
        Ix.convertTo(Ix, cv.CV_32F, 1.0/255);
        Iy.convertTo(Iy, cv.CV_32F, 1.0/255);

        let max_val;
        cv.magnitude(Iy, Ix, gradient_magnitude);
        let result = cv.minMaxLoc(gradient_magnitude);
        let maxPoint = result.maxVal;
        gradient_magnitude.convertTo(gradient_magnitude, cv.CV_32F, -1/maxPoint, 1.0);
        let pix = {x: 50, y: 50};
        find_min_path(pix);

      }

      document.getElementById("canvas").onmousedown = function(e)
      {
        lastX = e.pageX - this.offsetLeft;
        lastY = e.pageY - this.offsetTop;
      };


      document.getElementById("canvas").onmousemove = function(e)
      {
        if (lastX != undefined)
        {
          let x = e.pageX - this.offsetLeft;
          let y = e.pageY - this.offsetTop;
          
          while(x!=50 && y!=50)
          {
            cv.line(src, new cv.Point(hit_map_x.intPtr(x,y)[0], hit_map_y.intPtr(x,y)[0]), new cv.Point(x, y),
            new cv.Scalar(255, 255, 255, 255), 2);
            x=hit_map_x.intPtr(x,y)[0];
            y=hit_map_y.intPtr(x,y)[0];
          }
        
          cv.imshow("canvas", src);
          lastX = x;
          lastY = y;
        }
      }

      document.getElementById("canvas").onmouseup =
      document.getElementById("canvas").onmouseleave = function(e)
      {
          lastX = undefined;
          lastY = undefined;
      };

      function onOpenCvReady()
      {
        document.getElementById("status").innerHTML = "OpenCV.js is ready.";
        cv["onRuntimeInitialized"] = () =>
        {
          document.getElementById("startAlgo").disabled = false;
        }
      }

    </script>

    <script async src="https://docs.opencv.org/master/opencv.js" onload="onOpenCvReady();" type="text/javascript">
    </script>

  </body>
</html>