/*
 * file:   Subdiv2DBridge.cpp
 * author: A trusty code generator
 * date:   Tue, 28 Feb 2017 10:45:57
 *
 * This file was autogenerated, do not modify.
 * See LICENSE for full modification and redistribution details.
 * Copyright 2017 The OpenCV Foundation
 */
#include <mex.h>
#include <vector>
#include <string>
#include <opencv2/matlab/map.hpp>
#include <opencv2/matlab/bridge.hpp>
#include <opencv2/core.hpp>
using namespace cv;
using namespace matlab;
using namespace bridge;

namespace {

typedef std::vector<Bridge> (*)(Subdiv2D&, const std::vector<Bridge>&) MethodSignature;


// wrapper for Subdiv2D() constructor
Subdiv2D Subdiv2D(const std::vector<Bridge>& inputs) {
  

  Subdiv2D obj = cv::Subdiv2D();
  return obj;
}

// wrapper for Subdiv2D() constructor
Subdiv2D Subdiv2D(const std::vector<Bridge>& inputs) {
  
  // unpack the arguments
  Rect rect = inputs[0].toRect();

  Subdiv2D obj = cv::Subdiv2D(rect);
  return obj;
}

// wrapper for initDelaunay() method
std::vector<Bridge> initDelaunay(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs;
  
  // unpack the arguments
  Rect rect = inputs[0].toRect();

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.initDelaunay(rect);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in initDelaunay");
  }
  

  return outputs;
}

// wrapper for insert() method
std::vector<Bridge> insert(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  Point2f pt = inputs[0].toPoint2f();
  int retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.insert(pt);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in insert");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;

  return outputs;
}

// wrapper for insert() method
std::vector<Bridge> insert(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs;
  
  // unpack the arguments
  vector_Point2f ptvec = inputs[0].toVectorPoint2f();

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.insert(ptvec);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in insert");
  }
  

  return outputs;
}

// wrapper for locate() method
std::vector<Bridge> locate(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(3);
  
  // unpack the arguments
  Point2f pt = inputs[0].toPoint2f();
  int edge;
  int vertex;
  int retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.locate(pt, edge, vertex);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in locate");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;
  outputs[1] = edge;
  outputs[2] = vertex;

  return outputs;
}

// wrapper for findNearest() method
std::vector<Bridge> findNearest(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(2);
  
  // unpack the arguments
  Point2f pt = inputs[0].toPoint2f();
  Point2f nearestPt;
  int retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.findNearest(pt, &nearestPt);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in findNearest");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;
  outputs[1] = nearestPt;

  return outputs;
}

// wrapper for getEdgeList() method
std::vector<Bridge> getEdgeList(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  vector_Vec4f edgeList;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.getEdgeList(edgeList);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in getEdgeList");
  }
  
  // assign the outputs into the bridge
  outputs[0] = edgeList;

  return outputs;
}

// wrapper for getLeadingEdgeList() method
std::vector<Bridge> getLeadingEdgeList(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  vector_int leadingEdgeList;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.getLeadingEdgeList(leadingEdgeList);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in getLeadingEdgeList");
  }
  
  // assign the outputs into the bridge
  outputs[0] = leadingEdgeList;

  return outputs;
}

// wrapper for getTriangleList() method
std::vector<Bridge> getTriangleList(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  vector_Vec6f triangleList;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.getTriangleList(triangleList);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in getTriangleList");
  }
  
  // assign the outputs into the bridge
  outputs[0] = triangleList;

  return outputs;
}

// wrapper for getVoronoiFacetList() method
std::vector<Bridge> getVoronoiFacetList(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(2);
  
  // unpack the arguments
  vector_int idx = inputs[0].toVectorInt();
  vector_vector_Point2f facetList;
  vector_Point2f facetCenters;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.getVoronoiFacetList(idx, facetList, facetCenters);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in getVoronoiFacetList");
  }
  
  // assign the outputs into the bridge
  outputs[0] = facetList;
  outputs[1] = facetCenters;

  return outputs;
}

// wrapper for getVertex() method
std::vector<Bridge> getVertex(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(2);
  
  // unpack the arguments
  int vertex = inputs[0].toInt();
  int firstEdge;
  Point2f retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.getVertex(vertex, &firstEdge);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in getVertex");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;
  outputs[1] = firstEdge;

  return outputs;
}

// wrapper for getEdge() method
std::vector<Bridge> getEdge(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  int edge = inputs[0].toInt();
  int nextEdgeType = inputs[1].toInt();
  int retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.getEdge(edge, nextEdgeType);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in getEdge");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;

  return outputs;
}

// wrapper for nextEdge() method
std::vector<Bridge> nextEdge(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  int edge = inputs[0].toInt();
  int retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.nextEdge(edge);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in nextEdge");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;

  return outputs;
}

// wrapper for rotateEdge() method
std::vector<Bridge> rotateEdge(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  int edge = inputs[0].toInt();
  int rotate = inputs[1].toInt();
  int retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.rotateEdge(edge, rotate);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in rotateEdge");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;

  return outputs;
}

// wrapper for symEdge() method
std::vector<Bridge> symEdge(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  int edge = inputs[0].toInt();
  int retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.symEdge(edge);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in symEdge");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;

  return outputs;
}

// wrapper for edgeOrg() method
std::vector<Bridge> edgeOrg(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(2);
  
  // unpack the arguments
  int edge = inputs[0].toInt();
  Point2f orgpt;
  int retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.edgeOrg(edge, &orgpt);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in edgeOrg");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;
  outputs[1] = orgpt;

  return outputs;
}

// wrapper for edgeDst() method
std::vector<Bridge> edgeDst(Subdiv2D& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(2);
  
  // unpack the arguments
  int edge = inputs[0].toInt();
  Point2f dstpt;
  int retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.edgeDst(edge, &dstpt);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in edgeDst");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;
  outputs[1] = dstpt;

  return outputs;
}

Map<std::string, MethodSignature> createMethodMap() {
  Map<std::string, MethodSignature> m;
  m["Subdiv2D"] = &Subdiv2D;
  m["Subdiv2D"] = &Subdiv2D;
  m["initDelaunay"] = &initDelaunay;
  m["insert"] = &insert;
  m["insert"] = &insert;
  m["locate"] = &locate;
  m["findNearest"] = &findNearest;
  m["getEdgeList"] = &getEdgeList;
  m["getLeadingEdgeList"] = &getLeadingEdgeList;
  m["getTriangleList"] = &getTriangleList;
  m["getVoronoiFacetList"] = &getVoronoiFacetList;
  m["getVertex"] = &getVertex;
  m["getEdge"] = &getEdge;
  m["nextEdge"] = &nextEdge;
  m["rotateEdge"] = &rotateEdge;
  m["symEdge"] = &symEdge;
  m["edgeOrg"] = &edgeOrg;
  m["edgeDst"] = &edgeDst;

  return m;
}
static const Map<std::string, MethodSignature> methods = createMethodMap();

// map of created Subdiv2D instances. Don't trust the user to keep them safe...
static Map<void *, Subdiv2D> instances;

/*
 * Subdiv2D
 * Gateway routine
 *   nlhs - number of return arguments
 *   plhs - pointers to return arguments
 *   nrhs - number of input arguments
 *   prhs - pointers to input arguments
 */
void mexFunction(int nlhs, mxArray* plhs[],
                 int nrhs, const mxArray* prhs[]) {

  // parse the inputs
  Bridge method_name(prhs[0]);

  Bridge handle(prhs[1]);
  std::vector<Bridge> brhs(prhs+2, prhs+nrhs);

  // retrieve the instance of interest
  try {
    Subdiv2D& inst = instances.at(handle.address());
  } catch (const std::out_of_range& e) {
    mexErrMsgTxt("Invalid object instance provided");
  }

  // invoke the correct method on the data
  try {
    std::vector<Bridge> blhs = (*methods.at(method_name))(inst, brhs);
  } catch (const std::out_of_range& e) {
    mexErrMsgTxt("Unknown method specified");
  }



}

} // end namespace