/*
 * file:   fisheyeBridge.cpp
 * author: A trusty code generator
 * date:   Tue, 28 Feb 2017 10:45:57
 *
 * This file was autogenerated, do not modify.
 * See LICENSE for full modification and redistribution details.
 * Copyright 2017 The OpenCV Foundation
 */
#include <mex.h>
#include <vector>
#include <string>
#include <opencv2/matlab/map.hpp>
#include <opencv2/matlab/bridge.hpp>
#include <opencv2/core.hpp>
using namespace cv;
using namespace matlab;
using namespace bridge;

namespace {

typedef std::vector<Bridge> (*)(fisheye&, const std::vector<Bridge>&) MethodSignature;


// wrapper for projectPoints() method
std::vector<Bridge> projectPoints(fisheye& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(2);
  
  // unpack the arguments
  Mat objectPoints = inputs[0].toMat();
  Mat rvec = inputs[1].toMat();
  Mat tvec = inputs[2].toMat();
  Mat K = inputs[3].toMat();
  Mat D = inputs[4].toMat();
  double alpha = inputs[5].empty() ? (double) 0 : inputs[5].toDouble();
  Mat imagePoints;
  Mat jacobian;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.projectPoints(objectPoints, imagePoints, rvec, tvec, K, D, alpha, jacobian);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in projectPoints");
  }
  
  // assign the outputs into the bridge
  outputs[0] = imagePoints;
  outputs[1] = jacobian;

  return outputs;
}

// wrapper for distortPoints() method
std::vector<Bridge> distortPoints(fisheye& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  Mat undistorted = inputs[0].toMat();
  Mat K = inputs[1].toMat();
  Mat D = inputs[2].toMat();
  double alpha = inputs[3].empty() ? (double) 0 : inputs[3].toDouble();
  Mat distorted;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.distortPoints(undistorted, distorted, K, D, alpha);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in distortPoints");
  }
  
  // assign the outputs into the bridge
  outputs[0] = distorted;

  return outputs;
}

// wrapper for undistortPoints() method
std::vector<Bridge> undistortPoints(fisheye& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  Mat distorted = inputs[0].toMat();
  Mat K = inputs[1].toMat();
  Mat D = inputs[2].toMat();
  Mat R = inputs[3].empty() ? (Mat) Mat() : inputs[3].toMat();
  Mat P = inputs[4].empty() ? (Mat) Mat() : inputs[4].toMat();
  Mat undistorted;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.undistortPoints(distorted, undistorted, K, D, R, P);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in undistortPoints");
  }
  
  // assign the outputs into the bridge
  outputs[0] = undistorted;

  return outputs;
}

// wrapper for initUndistortRectifyMap() method
std::vector<Bridge> initUndistortRectifyMap(fisheye& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(2);
  
  // unpack the arguments
  Mat K = inputs[0].toMat();
  Mat D = inputs[1].toMat();
  Mat R = inputs[2].toMat();
  Mat P = inputs[3].toMat();
  Size size = inputs[4].toSize();
  int m1type = inputs[5].toInt();
  Mat map1;
  Mat map2;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.initUndistortRectifyMap(K, D, R, P, size, m1type, map1, map2);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in initUndistortRectifyMap");
  }
  
  // assign the outputs into the bridge
  outputs[0] = map1;
  outputs[1] = map2;

  return outputs;
}

// wrapper for undistortImage() method
std::vector<Bridge> undistortImage(fisheye& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  Mat distorted = inputs[0].toMat();
  Mat K = inputs[1].toMat();
  Mat D = inputs[2].toMat();
  Mat Knew = inputs[3].empty() ? (Mat) cv::Mat() : inputs[3].toMat();
  Size new_size = inputs[4].empty() ? (Size) Size() : inputs[4].toSize();
  Mat undistorted;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.undistortImage(distorted, undistorted, K, D, Knew, new_size);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in undistortImage");
  }
  
  // assign the outputs into the bridge
  outputs[0] = undistorted;

  return outputs;
}

// wrapper for estimateNewCameraMatrixForUndistortRectify() method
std::vector<Bridge> estimateNewCameraMatrixForUndistortRectify(fisheye& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(1);
  
  // unpack the arguments
  Mat K = inputs[0].toMat();
  Mat D = inputs[1].toMat();
  Size image_size = inputs[2].toSize();
  Mat R = inputs[3].toMat();
  double balance = inputs[4].empty() ? (double) 0.0 : inputs[4].toDouble();
  Size new_size = inputs[5].empty() ? (Size) Size() : inputs[5].toSize();
  double fov_scale = inputs[6].empty() ? (double) 1.0 : inputs[6].toDouble();
  Mat P;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.estimateNewCameraMatrixForUndistortRectify(K, D, image_size, R, P, balance, new_size, fov_scale);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in estimateNewCameraMatrixForUndistortRectify");
  }
  
  // assign the outputs into the bridge
  outputs[0] = P;

  return outputs;
}

// wrapper for calibrate() method
std::vector<Bridge> calibrate(fisheye& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(5);
  
  // unpack the arguments
  vector_Mat objectPoints = inputs[0].toVectorMat();
  vector_Mat imagePoints = inputs[1].toVectorMat();
  Size image_size = inputs[2].toSize();
  Mat K = inputs[3].toMat();
  Mat D = inputs[4].toMat();
  int flags = inputs[5].empty() ? (int) 0 : inputs[5].toInt();
  TermCriteria criteria = inputs[6].empty() ? (TermCriteria) TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON) : inputs[6].toTermCriteria();
  vector_Mat rvecs;
  vector_Mat tvecs;
  double retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.calibrate(objectPoints, imagePoints, image_size, K, D, rvecs, tvecs, flags, criteria);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in calibrate");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;
  outputs[1] = K;
  outputs[2] = D;
  outputs[3] = rvecs;
  outputs[4] = tvecs;

  return outputs;
}

// wrapper for stereoRectify() method
std::vector<Bridge> stereoRectify(fisheye& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(5);
  
  // unpack the arguments
  Mat K1 = inputs[0].toMat();
  Mat D1 = inputs[1].toMat();
  Mat K2 = inputs[2].toMat();
  Mat D2 = inputs[3].toMat();
  Size imageSize = inputs[4].toSize();
  Mat R = inputs[5].toMat();
  Mat tvec = inputs[6].toMat();
  int flags = inputs[7].toInt();
  Size newImageSize = inputs[8].empty() ? (Size) Size() : inputs[8].toSize();
  double balance = inputs[9].empty() ? (double) 0.0 : inputs[9].toDouble();
  double fov_scale = inputs[10].empty() ? (double) 1.0 : inputs[10].toDouble();
  Mat R1;
  Mat R2;
  Mat P1;
  Mat P2;
  Mat Q;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    inst.stereoRectify(K1, D1, K2, D2, imageSize, R, tvec, R1, R2, P1, P2, Q, flags, newImageSize, balance, fov_scale);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in stereoRectify");
  }
  
  // assign the outputs into the bridge
  outputs[0] = R1;
  outputs[1] = R2;
  outputs[2] = P1;
  outputs[3] = P2;
  outputs[4] = Q;

  return outputs;
}

// wrapper for stereoCalibrate() method
std::vector<Bridge> stereoCalibrate(fisheye& inst, const std::vector<Bridge>& inputs) {
  std::vector<Bridge> outputs(7);
  
  // unpack the arguments
  vector_Mat objectPoints = inputs[0].toVectorMat();
  vector_Mat imagePoints1 = inputs[1].toVectorMat();
  vector_Mat imagePoints2 = inputs[2].toVectorMat();
  Mat K1 = inputs[3].toMat();
  Mat D1 = inputs[4].toMat();
  Mat K2 = inputs[5].toMat();
  Mat D2 = inputs[6].toMat();
  Size imageSize = inputs[7].toSize();
  int flags = inputs[8].empty() ? (int) fisheye::CALIB_FIX_INTRINSIC : inputs[8].toInt();
  TermCriteria criteria = inputs[9].empty() ? (TermCriteria) TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON) : inputs[9].toTermCriteria();
  Mat R;
  Mat T;
  double retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = inst.stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, flags, criteria);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in stereoCalibrate");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;
  outputs[1] = K1;
  outputs[2] = D1;
  outputs[3] = K2;
  outputs[4] = D2;
  outputs[5] = R;
  outputs[6] = T;

  return outputs;
}

Map<std::string, MethodSignature> createMethodMap() {
  Map<std::string, MethodSignature> m;
  m["projectPoints"] = &projectPoints;
  m["distortPoints"] = &distortPoints;
  m["undistortPoints"] = &undistortPoints;
  m["initUndistortRectifyMap"] = &initUndistortRectifyMap;
  m["undistortImage"] = &undistortImage;
  m["estimateNewCameraMatrixForUndistortRectify"] = &estimateNewCameraMatrixForUndistortRectify;
  m["calibrate"] = &calibrate;
  m["stereoRectify"] = &stereoRectify;
  m["stereoCalibrate"] = &stereoCalibrate;

  return m;
}
static const Map<std::string, MethodSignature> methods = createMethodMap();

// map of created fisheye instances. Don't trust the user to keep them safe...
static Map<void *, fisheye> instances;

/*
 * fisheye
 * Gateway routine
 *   nlhs - number of return arguments
 *   plhs - pointers to return arguments
 *   nrhs - number of input arguments
 *   prhs - pointers to input arguments
 */
void mexFunction(int nlhs, mxArray* plhs[],
                 int nrhs, const mxArray* prhs[]) {

  // parse the inputs
  Bridge method_name(prhs[0]);

  Bridge handle(prhs[1]);
  std::vector<Bridge> brhs(prhs+2, prhs+nrhs);

  // retrieve the instance of interest
  try {
    fisheye& inst = instances.at(handle.address());
  } catch (const std::out_of_range& e) {
    mexErrMsgTxt("Invalid object instance provided");
  }

  // invoke the correct method on the data
  try {
    std::vector<Bridge> blhs = (*methods.at(method_name))(inst, brhs);
  } catch (const std::out_of_range& e) {
    mexErrMsgTxt("Unknown method specified");
  }



}

} // end namespace