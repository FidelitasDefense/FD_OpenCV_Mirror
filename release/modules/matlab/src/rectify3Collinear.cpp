/*
 * file:   rectify3Collinear.cpp
 * author: A trusty code generator
 * date:   Tue, 28 Feb 2017 10:45:57
 *
 * This file was autogenerated, do not modify.
 * See LICENSE for full modification and redistribution details.
 * Copyright 2017 The OpenCV Foundation
 */
#include <string>
#include <vector>
#include <cassert>
#include <exception>
#include <opencv2/matlab/bridge.hpp>
#include <opencv2/calib3d.hpp>
using namespace cv;
using namespace matlab;
using namespace bridge;

/*
 * rectify3Collinear
 * float rectify3Collinear(Mat cameraMatrix1, Mat distCoeffs1, Mat cameraMatrix2, Mat distCoeffs2, Mat cameraMatrix3, Mat distCoeffs3, vector_Mat imgpt1, vector_Mat imgpt3, Size imageSize, Mat R12, Mat T12, Mat R13, Mat T13, Mat R1, Mat R2, Mat R3, Mat P1, Mat P2, Mat P3, Mat Q, double alpha, Size newImgSize, Rect* roi1, Rect* roi2, int flags);
 * Gateway routine
 *   nlhs - number of return arguments
 *   plhs - pointers to return arguments
 *   nrhs - number of input arguments
 *   prhs - pointers to input arguments
 */
void mexFunction(int nlhs, mxArray* plhs[],
                 int nrhs, const mxArray* prhs[]) {

  // parse the inputs
  ArgumentParser parser("rectify3Collinear");
  parser.addVariant("rectify3Collinear", 16, 0);
  MxArrayVector sorted = parser.parse(MxArrayVector(prhs, prhs+nrhs));

  // setup
  BridgeVector inputs(sorted.begin(), sorted.end());
  BridgeVector outputs(10);

  
  // unpack the arguments
  Mat cameraMatrix1 = inputs[0].toMat();
  Mat distCoeffs1 = inputs[1].toMat();
  Mat cameraMatrix2 = inputs[2].toMat();
  Mat distCoeffs2 = inputs[3].toMat();
  Mat cameraMatrix3 = inputs[4].toMat();
  Mat distCoeffs3 = inputs[5].toMat();
  vector_Mat imgpt1 = inputs[6].toVectorMat();
  vector_Mat imgpt3 = inputs[7].toVectorMat();
  Size imageSize = inputs[8].toSize();
  Mat R12 = inputs[9].toMat();
  Mat T12 = inputs[10].toMat();
  Mat R13 = inputs[11].toMat();
  Mat T13 = inputs[12].toMat();
  double alpha = inputs[13].toDouble();
  Size newImgSize = inputs[14].toSize();
  int flags = inputs[15].toInt();
  Mat R1;
  Mat R2;
  Mat R3;
  Mat P1;
  Mat P2;
  Mat P3;
  Mat Q;
  Rect roi1;
  Rect roi2;
  float retval;

  // call the opencv function
  // [out =] namespace.fun(src1, ..., srcn, dst1, ..., dstn, opt1, ..., optn);
  try {
    retval = cv::rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, R1, R2, R3, P1, P2, P3, Q, alpha, newImgSize, &roi1, &roi2, flags);
  } catch(cv::Exception& e) {
    error(std::string("cv::exception caught: ").append(e.what()).c_str());
  } catch(std::exception& e) {
    error(std::string("std::exception caught: ").append(e.what()).c_str());
  } catch(...) {
    error("Uncaught exception occurred in rectify3Collinear");
  }
  
  // assign the outputs into the bridge
  outputs[0] = retval;
  outputs[1] = R1;
  outputs[2] = R2;
  outputs[3] = R3;
  outputs[4] = P1;
  outputs[5] = P2;
  outputs[6] = P3;
  outputs[7] = Q;
  outputs[8] = roi1;
  outputs[9] = roi2;


  // push the outputs back to matlab
  for (size_t n = 0; n < static_cast<size_t>(std::max(nlhs,1)); ++n) {
    plhs[n] = outputs[n].toMxArray().releaseOwnership();
  }
}